

**[Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)**

GivenÂ `head`, the head of a linked list, determine if the linked list has a cycle in it.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following theÂ `next`Â pointer. Internally,Â `pos`Â is used to denote the index of the node thatÂ tail'sÂ `next`Â pointer is connected to.Â **Note thatÂ `pos`Â is not passed as a parameter**.

ReturnÂ `true`Â _if there is a cycle in the linked list_. Otherwise, returnÂ `false`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)

```
Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png)

```
Input: head = [1,2], pos = 0
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.
```

**Example 3:**

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png)

```
Input: head = [1], pos = -1
Output: false
Explanation: There is no cycle in the linked list.
```


**Constraints:**

- The number of the nodes in the list is in the rangeÂ `[0, 104]`.
- `-105 <= Node.val <= 105`
- `pos`Â isÂ `-1`Â or aÂ **valid index**Â in the linked-list.

**Follow up:**Â Can you solve it usingÂ `O(1)`Â (i.e. constant) memory?

***

### Brute Force Approach

### Complexity

- Time complexity: O(n)
    
- Space complexity: O(n)
    

#### Algorithm

AÂ **loop**Â in a linked list occurs when thereâ€™s a node that,Â **when followed**,Â **brings you back**Â to it, indicating aÂ **closed loop**Â in the list.

![image.png](https://assets.leetcode.com/users/images/8ce47de1-2109-454e-83b7-2a60add02872_1707848360.7109401.png)

Hence itâ€™s important to keep track of nodes that have already been visited so that loops can be detected. One common way to do this is by using hashing.

##### Steps

**Step 1: Traverse**Â through the LL using the traversal technique of assigning aÂ **temp**Â node to the head andÂ **iterating**Â by moving to the next element till we reachÂ **null**.

![image.png](https://assets.leetcode.com/users/images/325b7cce-5959-47c1-ba08-00572251dcdc_1707848385.2723346.png)

**Step 2:**Â While traversing, keep a track of the visited nodes in the map data structure.Â 

![image.png](https://assets.leetcode.com/users/images/5e1acc49-4c3d-4e8c-a646-e7b2084e2431_1707848390.600607.png)

**Note:**Â Storing the entire node in the map is essential to distinguish between nodes withÂ **identical values**Â butÂ **different positions**Â in the list. This ensuresÂ **accurate loop detection**Â and not just duplicate value checks.

**Step 3:**Â If aÂ **previously**Â **visited**Â **node**Â is encountered again, that proves that there is aÂ **loop**Â in the linked list hence returnÂ **true**.

**Step 4:**Â If the traversal is completed, and we reach the last point of the LL which isÂ **null**, it means there wasÂ **noloop**, hence we returnÂ **false**.

### Code

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
// Brute Force Approach
// Time complexity -> O(n) and Space -> O(n)
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode *temp=head;
        unordered_map<ListNode*,int> mpp;
        while(temp!=nullptr)
        {
            if(mpp.find(temp)!=mpp.end())
            {
                return true;
            }
            mpp[temp]=1;
            temp=temp->next;
        }
        return false;
    }
};
```

### Optimized Approach [Tortoise and Hare Algorithm]

### Complexity

- Time complexity: O(n)
    
- Space complexity: O(1)
    

#### Algorithm

The previous method uses O(n)Â **additional**Â **memory**, which can become quite large as theÂ **linked**Â **list**Â **length**Â **grows**. To enhance efficiency, theÂ **Tortoise**Â andÂ **Hare**Â **Algorithm**Â is introduced as anÂ **optimization**.  

When theÂ **tortoise**Â andÂ **hare**Â enter the loop, they may be at different positions within the loop due to the difference in theirÂ **speeds**. The hare is movingÂ **faster**, so it will traverse aÂ **greater**Â **distance**Â in the same amount of time.

If there isÂ **no loop**Â in the linked list, the hare will eventually reach theÂ **end**, and the algorithm will terminate without a meeting occurring.

![image.png](https://assets.leetcode.com/users/images/deda9d8a-4627-448f-b56d-d7e5bb9df07e_1707848572.1286948.png)

##### Steps

**Step 1:**Â Initialise two pointers,Â **`slow`**Â andÂ **`fast`**, to the head of the linked list.Â **`slow`**Â will advanceÂ **one**Â **step**Â at a time, whileÂ **`fast`**Â will advanceÂ **two**Â **steps**Â at a time. These pointers will moveÂ **simultaneously**.

**Step 2:**Â Traverse the linked list with theÂ **`slow`**Â andÂ **`fast`**Â pointers. While traversing, repeatedly moveÂ **`slow`**Â **one**Â **step**Â andÂ **`fast`**Â **two**Â **steps**Â at a time.

**Step 3:**Â Continue this traversal until one of the following conditions is met:

1. **`fast**`Â orÂ **`fast.next`**Â reaches the end of the linked list (i.e., becomesÂ **null**). In this case, there isÂ **no loop**Â in the linked list ie. the linked list isÂ **linear**, and the algorithm terminates by returningÂ **false**.
    
2. **`fast`**Â andÂ **`slow`**Â pointers meet at the same node. This indicates the presence of aÂ **loop**Â in the linked list, and the algorithm terminates by returningÂ **`true`**.
    

![image.png](https://assets.leetcode.com/users/images/e62ca12c-aea4-4e48-a70d-f13d7b21d44b_1707848590.6137803.png)

##### Intuition:

In a linked list with a loop, consider two pointers: one that moves one node at a time (**slow**) and another that moves two nodes at a time (**fast**). If we start moving these pointers with their defined speed they will surely enter the loop and might be at some distanceÂ **â€˜dâ€™**Â from each other within the loop.

The key insight here is theÂ **relative**Â **speed**Â between these pointers. The fast pointer, moving at double the speed of the slow one,Â **closes**Â **the**Â **gap**Â between them byÂ **one**Â **node**Â **in**Â **every**Â **iteration**. This means that with each step, the distance decreases by one node.

Imagine a race where one runner moves atÂ **twice**Â the speed of another. The faster runner covers the ground faster and closes the gap, resulting in a reduction in the distance between them. Similarly, theÂ **fast**Â pointer catches up to theÂ **slow**Â pointer in the looped linked list, closing in the gap between them until it reaches zero.

##### Proof:

LetÂ **â€˜dâ€™**Â denote the initial distance between theÂ **slow**Â andÂ **fast**Â pointers inside the loop. At each step, the fast pointer moves ahead by two nodes while the slow pointer advances by one node.

![image.png](https://assets.leetcode.com/users/images/48123bb5-7442-4fb1-8cb1-fee7fb13e4f5_1707848629.7942324.png)

![image.png](https://assets.leetcode.com/users/images/5685b59b-1d35-41db-ac12-a5b108431a45_1707848641.413579.png)

TheÂ **relative**Â **speed**Â between them causes the gap to decrease by one node in each iteration (fast gains two nodes while slow gains one node). This continuous reduction ensures that the difference between their positionsÂ **decreases**Â **steadily**. Mathematically, if the fast pointerÂ **gains ground**Â twice as fast as the slow pointer, the difference in their positions reduces by one node after each step. Consequently, this reduction in the distance between them continuesÂ **until**Â theÂ **difference becomes zero**.

Hence, the proof lies in thisÂ **iterative**Â **process**Â where the faster rate of the fast pointer leads to a continual decrease in the gap distance, ultimately resulting in their collision within the looped linked list.

### Code

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
 
// Optimized Approach
// Time complexity -> O(n) and Space -> O(1)
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(head==NULL || head->next==NULL)
        {
            return false;
        }
        ListNode *slow,*fast;
        slow=fast=head;
        do
        {
            slow=slow->next;
            fast=fast->next;
            fast=fast!=NULL?fast->next:fast;
        }while(slow!=NULL && fast!=NULL && slow!=fast);

        return slow==fast?true:false;
    }
};
```

**OR**

```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) {
	
		// if head is NULL then return false;
        if(head == NULL)
        {
            return false;
        }

		// making two pointers fast and slow and assignning them to head
        ListNode *fast = head;
        ListNode *slow = head;
        
		// till fast and fast-> next not reaches NULL
		// we will increment fast by 2 step and slow by 1 step
        while(fast != NULL && fast ->next != NULL)
        {
            fast = fast->next->next;
            slow = slow->next;
            
			// At the point if fast and slow are at same address
			// this means linked list has a cycle in it.
            if(fast == slow)
            {
                return true;
            }
        }
		// if traversal reaches to NULL this means no cycle.
        return false;
    }
};
```


***

**Important Links**
1. **[Solution Link](https://leetcode.com/problems/linked-list-cycle/solutions/3375481/detailed-solution-easy-c-solution-brute-force-and-optimized-approach-with-explanation)**
2.  **[Video Link](https://youtu.be/wiOo4DC5GGA)**

***

**[For Detailed Solution](https://takeuforward.org/data-structure/detect-a-cycle-in-a-linked-list/)**

**Special Thanks to Striver ðŸ’™**